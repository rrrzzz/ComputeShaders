#pragma kernel WaveKernel
#pragma kernel WaveToMultiWaveKernel
#pragma kernel WaveToRippleKernel
#pragma kernel WaveToSphereKernel
#pragma kernel WaveToTorusKernel
#pragma kernel WaveToTorusAwesomeKernel

#pragma kernel MultiWaveKernel
#pragma kernel MultiWaveToWaveKernel
#pragma kernel MultiWaveToRippleKernel
#pragma kernel MultiWaveToSphereKernel
#pragma kernel MultiWaveToTorusKernel
#pragma kernel MultiWaveToTorusAwesomeKernel

#pragma kernel RippleKernel
#pragma kernel RippleToWaveKernel
#pragma kernel RippleToMultiWaveKernel
#pragma kernel RippleToSphereKernel
#pragma kernel RippleToTorusKernel
#pragma kernel RippleToTorusAwesomeKernel

#pragma kernel SphereKernel
#pragma kernel SphereToWaveKernel
#pragma kernel SphereToMultiWaveKernel
#pragma kernel SphereToRippleKernel
#pragma kernel SphereToTorusKernel
#pragma kernel SphereToTorusAwesomeKernel

#pragma kernel TorusKernel
#pragma kernel TorusToWaveKernel
#pragma kernel TorusToMultiWaveKernel
#pragma kernel TorusToRippleKernel
#pragma kernel TorusToSphereKernel
#pragma kernel TorusToTorusAwesomeKernel

#pragma kernel TorusAwesomeKernel
#pragma kernel TorusAwesomeToWaveKernel
#pragma kernel TorusAwesomeToMultiWaveKernel
#pragma kernel TorusAwesomeToRippleKernel
#pragma kernel TorusAwesomeToSphereKernel
#pragma kernel TorusAwesomeToTorusKernel

#define PI 3.14159265358979323846

float _Step, _Time, _TransitionProgress;
uint _Resolution;
RWStructuredBuffer<float3> _Positions;

float3 Wave(float u, float v, float t)
{
    float3 p;
            
    p.x = u;
    p.y = sin(PI * (u + v - t));
    p.z = v;

    return p;
}                                                                                
                                                                                    
float3 MultiWave(float u, float v, float t)                         
{                                                                                   
    float3 p;                                                                      
                                                                                    
    p.x = u;                                                                        
                                                                                    
    p.y = sin(PI * (u + t));                                            
    p.y += sin(2.0 * PI * (v + t)) * 0.5;                                
    p.y += sin(PI * (u + v + 0.25 * t));                               
    p.y *= 2.0 / 3.0;                                                                  
                                                                                    
    p.z = v;                                                                        
                                                                                    
    return p;                                                                       
}                                                                                   
                                                                                    
float3 Ripple(float u, float v, float t)                            
{                                                                                   
    float3 p;                                                                      
                                                                                    
    p.x = u;                                                                        
                                                                                    
    float d = sqrt(u * u + v * v);                                              
    p.y  = sin(PI * (4.0 * d - t)) / (2.0 + 30.0 * d);                     
                                                                                    
    p.z = v;                                                                        
                                                                                    
    return p;                                                                       
}                                                                                   
                                                                                    
float3 Sphere(float u, float v, float t)                            
{                                                                                   
    float3 p;

    float r = 0.9 + 0.1 * sin(PI * (12.0 * u + 8.0 * v + t));
    float s = r * cos(0.5 * PI * v);
    p.x = s * sin(PI * u);
    p.y = r * sin(0.5f * PI * v);
    p.z = s * cos(PI * u);
            
    return p;                                                            
}                                                                                   
//                                                                                     
// float3 Torus(float u, float v, float t)                             
// {                                                                                   
//     float3 p;                                                                      
//     float rOuter = 0.7 + 0.1 * sin(PI * (6.0 * u + 0.5 * t));           
//     float rWidth = 0.15 + 0.05 * sin(PI * (8.0 * u + 4.0 * v + 2.0 * t));  
//     float s = rOuter + rWidth * cos(v * PI);                              
//     p.x = s * sin(PI * u);                                              
//     p.y = rWidth * sin(v * PI);                                         
//     p.z = s * cos(PI * u);                                              
//                                                                                     
//     return p;                                                                       
// }

float3 Torus(float u, float v, float t)                             
{                                                                                   
    float3 p;                                                                      
    float r1 = 0.7 + 0.1 * sin(PI * (16.0 * u + 1.0 * t));
    float r2 = 0.15 + 0.05 * sin(PI * (32.0 * u + 8.0 * v + 6.0 * t));
    float s = r1 + r2 * cos(v * PI);                              
    p.x = s * sin(PI * u);                                              
    p.y = r2 * sin(v * PI);                                         
    p.z = s * cos(PI * u);                                              
                                                                                    
    return p;                                                                       
}  
                                                                                    
float3 TorusAwesome(float u, float v, float t)                      
{                                                                                   
    float3 p;                                                                      
    float r = cos(PI * 2.0 * v + t);                                        
    float s = 0.05f + 0.6f + r * cos(v * PI);                             
    p.x = s * sin(PI * u);                                              
    p.y = r * sin(v * PI);                                              
    p.z = s * cos(PI * u);                                              
                                                                                    
    return p;                                                                       
}                                                                                   

float2 GetUV(uint3 id)
{
    return (id.xy + .5) * _Step - 1.0;
}

void SetPosition(uint3 id, float3 position)
{
    if (id.x < _Resolution && id.y < _Resolution)
    {
        _Positions[id.x + id.y * _Resolution] = position;
    }
}

#define KERNEL_FUNCTION(function)\
[numthreads(8,8,1)]\
void function##Kernel(uint3 id: SV_DispatchThreadID)\
{\
float2 uv = GetUV(id);\
float3 position = function(uv.x, uv.y, _Time);\
SetPosition(id, position);\
}

#define KERNEL_MORPH_FUNCTION(functionA, functionB)\
[numthreads(8,8,1)]\
void functionA##To##functionB##Kernel(uint3 id: SV_DispatchThreadID)\
{\
float2 uv = GetUV(id);\
float3 firstOutput = functionA(uv.x, uv.y, _Time);\
float3 secondOutput = functionB(uv.x, uv.y, _Time);\
float3 position = lerp(firstOutput, secondOutput, _TransitionProgress);\
SetPosition(id, position);\
}

KERNEL_FUNCTION(Wave)
KERNEL_FUNCTION(MultiWave)
KERNEL_FUNCTION(Ripple)
KERNEL_FUNCTION(Sphere)
KERNEL_FUNCTION(Torus)
KERNEL_FUNCTION(TorusAwesome)

KERNEL_MORPH_FUNCTION(Wave, MultiWave);
KERNEL_MORPH_FUNCTION(Wave, Ripple);
KERNEL_MORPH_FUNCTION(Wave, Sphere);
KERNEL_MORPH_FUNCTION(Wave, Torus);
KERNEL_MORPH_FUNCTION(Wave, TorusAwesome);         
KERNEL_MORPH_FUNCTION(MultiWave, Wave);
KERNEL_MORPH_FUNCTION(MultiWave, Ripple);
KERNEL_MORPH_FUNCTION(MultiWave, Sphere);
KERNEL_MORPH_FUNCTION(MultiWave, Torus);
KERNEL_MORPH_FUNCTION(MultiWave, TorusAwesome);         
KERNEL_MORPH_FUNCTION(Ripple, Wave);
KERNEL_MORPH_FUNCTION(Ripple, MultiWave);
KERNEL_MORPH_FUNCTION(Ripple, Sphere);
KERNEL_MORPH_FUNCTION(Ripple, Torus);
KERNEL_MORPH_FUNCTION(Ripple, TorusAwesome);         
KERNEL_MORPH_FUNCTION(Sphere, Wave);
KERNEL_MORPH_FUNCTION(Sphere, MultiWave);
KERNEL_MORPH_FUNCTION(Sphere, Ripple);
KERNEL_MORPH_FUNCTION(Sphere, Torus);
KERNEL_MORPH_FUNCTION(Sphere, TorusAwesome);         
KERNEL_MORPH_FUNCTION(Torus, Wave);
KERNEL_MORPH_FUNCTION(Torus, MultiWave);
KERNEL_MORPH_FUNCTION(Torus, Ripple);
KERNEL_MORPH_FUNCTION(Torus, Sphere);
KERNEL_MORPH_FUNCTION(Torus, TorusAwesome);
KERNEL_MORPH_FUNCTION(TorusAwesome, Wave);
KERNEL_MORPH_FUNCTION(TorusAwesome, MultiWave);
KERNEL_MORPH_FUNCTION(TorusAwesome, Ripple);
KERNEL_MORPH_FUNCTION(TorusAwesome, Sphere);
KERNEL_MORPH_FUNCTION(TorusAwesome, Torus);
